{"ast":null,"code":"'use strict'; // In production, we register a service worker to serve assets from local cache.\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n\n/**\n * The default register service worker function\n * @returns {AppServiceWorker}\n */\n\nfunction registerServiceWorker() {\n  return AppServiceWorker.getInstance();\n}\n/**\n * App Service Worker Class\n * \n * @export\n * @class AppServiceWorker\n */\n\n\nexport class AppServiceWorker {\n  /**\n   * Creates an instance of AppServiceWorker.\n   * \n   * @memberof AppServiceWorker\n   */\n  constructor() {\n    this.isLocalhost = Boolean(window.location.hostname === \"localhost\" || // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" || // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));\n    this.installPromise = new Promise(resolve => this.installPromiseResolver = resolve);\n    this.updatePromise = new Promise(resolve => this.updatePromiseResolver = resolve);\n    this.onUpdateFound(() => console.log(\"New content is available; please refresh.\"));\n    this.onInstalled(() => console.log(\"Content is cached for offline use.\"));\n  }\n  /**\n   * Register the service worker\n   * \n   * @returns \n   * @memberof AppServiceWorker\n   */\n\n\n  register() {\n    if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n      // The URL constructor is available in all browsers that support SW.\n      const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n\n      if (publicUrl.origin !== window.location.origin) {\n        // Our service worker won't work if PUBLIC_URL is on a different origin\n        // from what our page is served on. This might happen if a CDN is used to\n        // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n        return;\n      }\n\n      window.addEventListener(\"load\", () => {\n        const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n        if (this.isLocalhost) {\n          // This is running on localhost. Lets check if a service worker still exists or not.\n          this.checkValidServiceWorker(swUrl); // Add some additional logging to localhost, pointing developers to the\n          // service worker/PWA documentation.\n\n          navigator.serviceWorker.ready.then(() => {\n            console.log(\"This web app is being served cache-first by a service \" + \"worker. To learn more, visit https://goo.gl/SC7cgQ\");\n          });\n        } else {\n          // Is not local host. Just register service worker\n          this.registerValidSW(swUrl);\n        }\n      });\n    }\n\n    return this;\n  }\n\n  registerValidSW(swUrl) {\n    navigator.serviceWorker.register(swUrl).then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              this.updatePromiseResolver();\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              this.installPromiseResolver();\n            }\n          }\n        };\n      };\n    }).catch(error => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n  }\n\n  checkValidServiceWorker(swUrl) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl).then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (response.status === 404 || response.headers.get(\"content-type\").indexOf(\"javascript\") === -1) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        this.registerValidSW(swUrl);\n      }\n    }).catch(() => {\n      console.log(\"No internet connection found. App is running in offline mode.\");\n    });\n  }\n\n  unregister() {\n    if (\"serviceWorker\" in navigator) {\n      navigator.serviceWorker.ready.then(registration => {\n        registration.unregister();\n      });\n    }\n  }\n\n  onInstalled(callback) {\n    this.installPromise.then(callback).catch(console.error);\n  }\n\n  onUpdateFound(callback) {\n    this.updatePromise.then(callback).catch(console.error);\n  }\n\n  static getInstance() {\n    return this.instance ? this.instance : this.instance = new this().register();\n  }\n\n}\nexport default registerServiceWorker;","map":{"version":3,"sources":["C:/Users/moss/Documents/my-app/client/node_modules/react-service-worker/index.js"],"names":["registerServiceWorker","AppServiceWorker","getInstance","constructor","isLocalhost","Boolean","window","location","hostname","match","installPromise","Promise","resolve","installPromiseResolver","updatePromise","updatePromiseResolver","onUpdateFound","console","log","onInstalled","register","process","env","NODE_ENV","navigator","publicUrl","URL","PUBLIC_URL","origin","addEventListener","swUrl","checkValidServiceWorker","serviceWorker","ready","then","registerValidSW","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","catch","error","fetch","response","status","headers","get","indexOf","unregister","reload","callback","instance"],"mappings":"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","sourcesContent":["'use strict';\n\n// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n\n/**\n * The default register service worker function\n * @returns {AppServiceWorker}\n */\nfunction registerServiceWorker() {\n    return AppServiceWorker.getInstance()\n}\n\n/**\n * App Service Worker Class\n * \n * @export\n * @class AppServiceWorker\n */\nexport class AppServiceWorker {\n    /**\n     * Creates an instance of AppServiceWorker.\n     * \n     * @memberof AppServiceWorker\n     */\n    constructor() {\n\n        this.isLocalhost = Boolean(\n            window.location.hostname === \"localhost\" ||\n            // [::1] is the IPv6 localhost address.\n            window.location.hostname === \"[::1]\" ||\n            // 127.0.0.1/8 is considered localhost for IPv4.\n            window.location.hostname.match(\n                /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n            )\n        );\n\n        this.installPromise = new Promise(resolve => this.installPromiseResolver = resolve)\n        this.updatePromise = new Promise(resolve => this.updatePromiseResolver = resolve)\n\n        this.onUpdateFound(() => console.log(\"New content is available; please refresh.\"))\n        this.onInstalled(() => console.log(\"Content is cached for offline use.\"))\n\n    }\n    /**\n     * Register the service worker\n     * \n     * @returns \n     * @memberof AppServiceWorker\n     */\n    register() {\n        if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n            // The URL constructor is available in all browsers that support SW.\n            const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n            if (publicUrl.origin !== window.location.origin) {\n                // Our service worker won't work if PUBLIC_URL is on a different origin\n                // from what our page is served on. This might happen if a CDN is used to\n                // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n                return;\n            }\n\n            window.addEventListener(\"load\", () => {\n                const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n                if (this.isLocalhost) {\n                    // This is running on localhost. Lets check if a service worker still exists or not.\n                    this.checkValidServiceWorker(swUrl);\n\n                    // Add some additional logging to localhost, pointing developers to the\n                    // service worker/PWA documentation.\n                    navigator.serviceWorker.ready.then(() => {\n                        console.log(\n                            \"This web app is being served cache-first by a service \" +\n                            \"worker. To learn more, visit https://goo.gl/SC7cgQ\"\n                        );\n                    });\n                } else {\n                    // Is not local host. Just register service worker\n                    this.registerValidSW(swUrl);\n                }\n            });\n        }\n        return this\n    }\n\n    registerValidSW(swUrl) {\n\n        navigator.serviceWorker\n            .register(swUrl)\n            .then(registration => {\n\n                registration.onupdatefound = () => {\n                    const installingWorker = registration.installing;\n                    installingWorker.onstatechange = () => {\n                        if (installingWorker.state === \"installed\") {\n                            if (navigator.serviceWorker.controller) {\n                                // At this point, the old content will have been purged and\n                                // the fresh content will have been added to the cache.\n                                // It's the perfect time to display a \"New content is\n                                // available; please refresh.\" message in your web app.\n                                this.updatePromiseResolver()\n                            } else {\n                                // At this point, everything has been precached.\n                                // It's the perfect time to display a\n                                // \"Content is cached for offline use.\" message.\n                                this.installPromiseResolver()\n                            }\n                        }\n                    };\n                };\n            })\n            .catch(error => {\n                console.error(\"Error during service worker registration:\", error);\n            });\n    }\n\n    checkValidServiceWorker(swUrl) {\n        // Check if the service worker can be found. If it can't reload the page.\n        fetch(swUrl)\n            .then(response => {\n                // Ensure service worker exists, and that we really are getting a JS file.\n                if (\n                    response.status === 404 ||\n                    response.headers.get(\"content-type\").indexOf(\"javascript\") === -1\n                ) {\n                    // No service worker found. Probably a different app. Reload the page.\n                    navigator.serviceWorker.ready.then(registration => {\n                        registration.unregister().then(() => {\n                            window.location.reload();\n                        });\n                    });\n                } else {\n                    // Service worker found. Proceed as normal.\n                    this.registerValidSW(swUrl);\n                }\n            })\n            .catch(() => {\n                console.log(\n                    \"No internet connection found. App is running in offline mode.\"\n                );\n            });\n    }\n\n    unregister() {\n        if (\"serviceWorker\" in navigator) {\n            navigator.serviceWorker.ready.then(registration => {\n                registration.unregister();\n            });\n        }\n    }\n\n    onInstalled(callback) {\n        this.installPromise.then(callback).catch(console.error)\n\n    }\n\n    onUpdateFound(callback) {\n        this.updatePromise.then(callback).catch(console.error)\n    }\n\n    static getInstance() {\n        return this.instance ? this.instance : this.instance = new this().register()\n    }\n}\n\nexport default registerServiceWorker;"]},"metadata":{},"sourceType":"module"}